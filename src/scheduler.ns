import {getServerList} from "utilities.ns"

/** @param {NS} ns **/
export async function main(ns) {
	let targets = [ns.args[0]]
	ns.tprint(targets)
    let servers = getServerList(ns)
	servers = servers.filter(f => f !== "iron-gym") // TODO temporary
	schedule(ns, servers, targets)
}

async function schedule(ns, servers, targets) {
	ns.tprint("here")
	let nThreads = getTotalThreads(ns, servers, 1.75)
	ns.tprint(nThreads)
	nThreads = Math.floor(nThreads / targets.length)
	ns.tprint(nThreads)
	for (const target of targets) {
		ns.tprint(target)
		await scheduleAttack(ns, servers, nThreads, target)
	}
}

async function scheduleAttack(ns, servers, nThreads, target) {
	let threadsCount = getThreadsRatio(ns, target)
	ns.tprint(threadsCount)
	let times = [ns.getHackTime(target), ns.getGrowTime(target), ns.getWeakenTime(target)]
	ns.tprint(times)
	let roundTime = Math.ceil(Math.max(times))
	ns.tprint(roundTime)
	let timeIncrement = getTimeIncrement(ns, roundTime, times, threadsCount, nThreads)
	ns.tprint(timeIncrement)
	
	let serverMapping = getServerMapping(servers, times, timeIncrement, threadsCount)
	ns.tprint(serverMapping)
	
	await deploy(serverMapping, target)
}

async function deploy(ns, serverMapping, target) {
	scripts = ["hack.ns", "grow.ns", "weaken.ns"]
	while (true) {
		for (let i = 0; i < 3; i++) {
			for (const [server, nThreads] of serverMapping[i]) {
				ns.exec(scripts[i], server, nThreads, target)
			}
		}
		await ns.sleep(Maths.floor(timeIncrement * 1000))
	}
}

function getThreadsRatio(ns, server) {
	let hackPercent = ns.hackAnalyze(server)
	let growthNeeded = (1 / (1 - hackPercent)) * ns.hackAnalyzeChance(server) * 1.01
	let nGrowthThreads = Math.ceil(ns.growthAnalyze(server, growthNeeded))
	
	let nHackThreads = 1
	if (nGrowthThreads < 0.5) {
		nHackThreads = Maths.floor(1 / nGrowthThreads)
	}

	let securityIncrease = ns.hackAnalyzeSecurity(nHackThreads) + ns.growthAnalyzeSecurity(nGrowthThreads)
	let nWeakenThreads = Math.ceil(securityIncrease / ns.weakenAnalyze(1))

	return [nHackThreads, nGrowthThreads, nWeakenThreads]
}

function getServerMapping(servers, times, timeIncrement, threadsCount) {
	const ramPerThread = 1.75
	let serverInd = 0
	let serverIndUsed = 0
	let serverMapping = [{},{},{}] // empty dicts
	let divisions = getDivisions(times, timeIncrement)
	for (let i = 0; i < 3; i++) {
		let n = divisions[i] * threadsCount[i]
		let nFound = 0
		while (nFound < n) {
			let server = servers[serverInd]
			let nAdd = Math.min(getServerThreads(ns, server, ramPerThread) - serverIndUsed, n - nFound)
			if (nAdd == 0) {
				serverInd += 1
				serverIndUsed = 0
			} else {
				serverMapping[i][server] = nAdd
				serverIndUsed += nAdd
			}
		}	
	}
	return serverMapping
}

function getServerThreads(ns, server, ramPerThread) {
	return Math.floor(ns.getServerMaxRam(server) / ramPerThread)
}

function getTimeIncrement(ns, roundTime, times, threadsCount, maxNThreads) {
	const searchSteps = 0.01
	let threadsCountSum = threadsCount[0] + threadsCount[1] + threadsCount[2]
	let timeIncrement = (roundTime / maxNThreads) * (threadsCount[0] / times[0] + threadsCount[1] / times[1] + threadsCount[2] / times[2])
	let numThreads = getRequiredNumThreads(times, threadsRatio, timeIncrement)
	// adjust timeIncrement // TODO binary search without initial guess
	while (numThreads > maxNThreads || numThreads < maxNThreads - threadsCountSum) {
		if (numThreads > maxNThreads) { 
			timeIncrement += searchSteps
		} else {
			timeIncrement -= searchSteps
		}
		let numThreads = getRequiredNumThreads(times, threadsRatio, timeIncrement)
	}
	return timeIncrement
}

function getRequiredNumThreads(times, threadsCount, timeIncrement) {
	let num = 0
	let divisions = getDivisions(times, timeIncrement) 
	for (let i = 0; i < 3; i++) {
		num += divisions[i] * threadsCount[i]
	}
	return num
}

function getDivisions(times, timeIncrement) {
	let divisions = []
	for (let i = 0; i < 3; i++) {
		divisions.push(Math.ceil(times[i] / timeIncrement))
	}
	return divisions
}

function getTotalThreads(ns, servers, ramPerThread) {
	num = 0
	ns.tprint("h2")
	for (server of servers) {
		ns.tprint(server)
		//num += getServerThreads(ns, server, ramPerThread)
	}
	return num
}