import {getServerList} from "utilities.ns"

/** @param {NS} ns **/
export async function main(ns) {
	let targets = [ns.args[0]]
    let servers = getServerList(ns)
	servers = servers.filter(f => (f !== "iron-gym") && (f !== ".") && (f !== "home")) // TODO temporary
	await schedule(ns, servers, targets)
}

async function schedule(ns, servers, targets) {
	let nThreads = getTotalThreads(ns, servers, 1.75)
	nThreads = Math.floor(nThreads / targets.length)
	for (const target of targets) {
		await scheduleAttack(ns, servers, nThreads, target)
	}
}

async function scheduleAttack(ns, servers, nThreads, target) {
	let threadsCount = getThreadsRatio(ns, target)
	let times = [ns.getHackTime(target), ns.getGrowTime(target), ns.getWeakenTime(target)]
	let roundTime = Math.ceil(Math.max(...times))
	let timeIncrement = getTimeIncrement(roundTime, times, threadsCount, nThreads)
	
	let serverMapping = getServerMapping(ns, servers, times, timeIncrement, threadsCount)
	await deploy(ns, serverMapping, target, threadsCount, timeIncrement)
}

async function deploy(ns, serverMapping, target, threadsCount, timeIncrement) {
	let scripts = ["hack.ns", "grow.ns", "weaken.ns"]
	let lastServer = [[0,0], [0,0], [0,0]] // lastServer index; used slots
	let sleepTime = Math.floor(timeIncrement / 3)
	let id = 0
	while (true) {
		for (let i = 0; i < 3; i++) {
			lastServer[i] = start(ns, scripts[i], target, threadsCount[i], serverMapping[i], lastServer[i], id++)
			if (id > 10000) {
				id = 0
			}

			await ns.sleep(sleepTime);
		}
	}
}

function start(ns, script, target, nThreads, serverMap, lastServer, id) {
	let requiredThreads = nThreads
	let serverInd = lastServer[0]
	let usedThreads = lastServer[1]
	let randId = id
	while (requiredThreads > 0) {
		let freeThreads = serverMap[serverInd][1] - usedThreads
		let runThreads = Math.min(requiredThreads, freeThreads)
		let server = serverMap[serverInd][0]
		ns.exec(script, server, runThreads, target, randId++)
		requiredThreads -= runThreads
		if (freeThreads == runThreads) {
			serverInd++
			if (serverInd == serverMap.length) {
				serverInd = 0
			}
			usedThreads = 0
		} else {
			usedThreads += runThreads
		}
	}
	return [serverInd, usedThreads]
}

function getThreadsRatio(ns, server) {
	const maxHackThreads = 100
	let hackPercent = ns.hackAnalyze(server)
	let growthNeeded = (1 / (1 - hackPercent * ns.hackAnalyzeChance(server))) * 1.01
	let nGrowthThreads = ns.growthAnalyze(server, growthNeeded)

	let securityIncrease = ns.hackAnalyzeSecurity(1) + nGrowthThreads * ns.growthAnalyzeSecurity(1)
	let nWeakenThreads = securityIncrease / ns.weakenAnalyze(1)

	let mult = Math.min(maxHackThreads, Math.max(1/nGrowthThreads, 1/nWeakenThreads))

	let nHackThreads = Math.max(1, Math.floor(mult))
	nGrowthThreads = Math.ceil(nGrowthThreads * mult)
	nWeakenThreads = Math.ceil(nWeakenThreads * mult)

	return [nHackThreads, nGrowthThreads, nWeakenThreads]
}

function getServerMapping(ns, servers, times, timeIncrement, threadsCount) {
	const ramPerThread = 1.75
	let serverInd = 0
	let serverIndUsed = 0
	let serverMapping = [[],[],[]] // empty tuple lists
	let divisions = getDivisions(times, timeIncrement)
	for (let i = 0; i < 3; i++) {
		let n = divisions[i] * threadsCount[i]
		let nFound = 0
		while (nFound < n) {
			let server = servers[serverInd]
			let nAdd = Math.min(getServerThreads(ns, server, ramPerThread) - serverIndUsed, n - nFound)
			if (nAdd == 0) {
				serverInd += 1
				serverIndUsed = 0
			} else {
				serverMapping[i].push([server, nAdd])
				serverIndUsed += nAdd
				nFound += nAdd
			}
		}	
	}
	return serverMapping
}

function getServerThreads(ns, server, ramPerThread) {
	return Math.floor(ns.getServerMaxRam(server) / ramPerThread)
}

function getTimeIncrement(roundTime, times, threadsCount, maxNThreads) {
	const searchSteps = 0.01
	let threadsCountSum = threadsCount[0] + threadsCount[1] + threadsCount[2] 
	
	let lower = 0.01
	let upper = 10000

	// adjust timeIncrement // TODO binary search without initial guess
	for (let i = 0; i < 20; i++) {
		let middle = (lower + upper) / 2 
		let numThreads = getRequiredNumThreads(times, threadsCount, middle)
		if (numThreads > maxNThreads) { 
			lower = middle
		} else {
			upper = middle
		}
	}
	return upper
}

function getRequiredNumThreads(times, threadsCount, timeIncrement) {
	let num = 0
	let divisions = getDivisions(times, timeIncrement) 
	for (let i = 0; i < 3; i++) {
		num += divisions[i] * threadsCount[i]
	}
	return num
}

function getDivisions(times, timeIncrement) {
	let divisions = []
	for (let i = 0; i < 3; i++) {
		divisions.push(Math.ceil(times[i] / timeIncrement))
	}
	return divisions
}

function getTotalThreads(ns, servers, ramPerThread) {
	let num = 0
	for (const server of servers) {
		num += getServerThreads(ns, server, ramPerThread)
	}
	return num
}