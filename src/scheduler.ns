import {getServerList} from "utilities.ns"
import {fullWeaken} from "fullWeaken.ns"

/** @param {NS} ns **/
export async function main(ns) {
	ns.disableLog('ALL');
	while (true) {
		let targets = [getMoneyTarget(ns)]
		let servers = getServerList(ns)
		servers = servers.filter(f => (f !== ".") && (f !== "home") && ns.hasRootAccess(f))
		await schedule(ns, servers, targets)
	}
}

function getMoneyTarget(ns) {
	const serverFile = "servers_money_factor.txt"
	const servers = JSON.parse(ns.read(serverFile))
	ns.tprint(servers)
	let maxValue = 0
	let maxServer = "n00dles"
	for (let server in servers) {
		const value = servers[server]
		if (value > maxValue) {
			maxValue = value
			maxServer = server
		}
	}
	return maxServer
}

async function schedule(ns, servers, targets) {
	let nThreads = getTotalThreads(ns, servers, 1.75)
	nThreads = Math.floor(nThreads / targets.length)
	for (const target of targets) {
		await scheduleAttack(ns, servers, nThreads, target)
	}
}

function getTimes(ns, target) {
	return [ns.getHackTime(target), ns.getGrowTime(target), ns.getWeakenTime(target)]
}

async function scheduleAttack(ns, servers, nThreads, target) {
	await fullWeaken(ns, target)
	let threadsCount = getThreadsRatio(ns, target)
	let times = getTimes(ns, target)
	let timeIncrement = 1.2 * getTimeIncrement(ns, target, threadsCount, nThreads)
	
	let serverMapping = getServerMapping(ns, servers, times, timeIncrement, threadsCount)
	ns.print("Server Mapping: " + serverMapping)
	for (let i = 0; i < 3; i++) {
		let num = 0
		for (const entry of serverMapping[i]) {
			num += entry[1]
		}
		ns.print("index: " + i + " num: " + num)
	}
	ns.print("Threads Count: " + threadsCount)
	ns.print("Time increment: " + timeIncrement)
	ns.print("Times: " + times)
	ns.print("Total threads: " + nThreads)
	await deploy(ns, serverMapping, target, threadsCount, timeIncrement)
}

async function deploy(ns, serverMapping, target, threadsCount, timeIncrement) {
	let scripts = ["hack.ns", "grow.ns", "weaken.ns"]
	let lastServer = [[0,0], [0,0], [0,0]] // lastServer index; used slots
	let sleepTime = Math.floor(timeIncrement / 3)
	let id = 0
	let times = getTimes(ns, target)
	const initialTime = times[2] - times[0]
	let currentTime = 0
	const loops = 3600000 / sleepTime // every 60min
	for (let _ = 0; _ < loops; _++) {
		for (let i = 0; i < 3; i++) {
			if (i == 2 || currentTime > initialTime) { // only weaken in beginning
				lastServer[i] = start(ns, scripts[i], target, threadsCount[i], serverMapping[i], lastServer[i], id++)
			}
			if (id > 10000) {
				id = 0
			}

			await ns.sleep(sleepTime);
			currentTime += sleepTime
		}
	}
	ns.sleep(times[2]) // wait for last weaken to finish
}

function start(ns, script, target, nThreads, serverMap, lastServer, id) {
	let requiredThreads = nThreads
	let serverInd = lastServer[0]
	let usedThreads = lastServer[1]
	let randId = id
	while (requiredThreads > 0) {
		let freeThreads = serverMap[serverInd][1] - usedThreads
		let runThreads = Math.min(requiredThreads, freeThreads)
		let server = serverMap[serverInd][0]
		let success = ns.exec(script, server, runThreads, target, randId++)
		if (success == 0) {
			ns.tprint("Exec failed: " + server + " " + script)
		}
		requiredThreads -= runThreads
		if (freeThreads == runThreads) {
			serverInd++
			if (serverInd == serverMap.length) {
				serverInd = 0
			}
			usedThreads = 0
		} else {
			usedThreads += runThreads
		}
	}
	return [serverInd, usedThreads]
}

export function getThreadsRatio(ns, server) {
	const maxHackThreads = 100
	let hackPercent = ns.hackAnalyze(server)
	let growthNeeded = (1 / (1 - hackPercent)) * 1.05
	let nGrowthThreads = ns.growthAnalyze(server, growthNeeded)

	let securityIncrease = (ns.hackAnalyzeSecurity(1) + nGrowthThreads * ns.growthAnalyzeSecurity(1)) * 1.1
	let nWeakenThreads = securityIncrease / ns.weakenAnalyze(1)

	let mult = Math.min(maxHackThreads, Math.max(1/nGrowthThreads, 1/nWeakenThreads))

	let nHackThreads = Math.max(1, Math.floor(mult))
	nGrowthThreads = Math.ceil(nGrowthThreads * mult)
	nWeakenThreads = Math.ceil(nWeakenThreads * mult)

	return [nHackThreads, nGrowthThreads, nWeakenThreads]
}

function getServerMapping(ns, servers, times, timeIncrement, threadsCount) {
	const ramPerThread = 1.75
	let serverInd = 0
	let serverIndUsed = 0
	let serverMapping = [[],[],[]] // empty tuple lists
	let divisions = getDivisions(times, timeIncrement)
	for (let i = 0; i < 3; i++) {
		let n = divisions[i] * threadsCount[i]
		let nFound = 0
		while (nFound < n) {
			let server = servers[serverInd]
			let nAdd = Math.min(getServerThreads(ns, server, ramPerThread) - serverIndUsed, n - nFound)
			if (nAdd == 0) {
				serverInd += 1
				serverIndUsed = 0
			} else {
				serverMapping[i].push([server, nAdd])
				serverIndUsed += nAdd
				nFound += nAdd
			}
		}	
	}
	return serverMapping
}

function getServerThreads(ns, server, ramPerThread) {
	return Math.floor(ns.getServerMaxRam(server) / ramPerThread)
}

export function getTimeIncrement(ns, target, threadsCount, maxNThreads) {
	let times = getTimes(ns, target)
	
	let lower = 0.01
	let upper = 10000

	// adjust timeIncrement // TODO binary search without initial guess
	for (let i = 0; i < 20; i++) {
		let middle = (lower + upper) / 2 
		let numThreads = getRequiredNumThreads(times, threadsCount, middle)
		if (numThreads > maxNThreads) { 
			lower = middle
		} else {
			upper = middle
		}
	}
	return upper
}

function getRequiredNumThreads(times, threadsCount, timeIncrement) {
	let num = 0
	let divisions = getDivisions(times, timeIncrement) 
	for (let i = 0; i < 3; i++) {
		num += divisions[i] * threadsCount[i]
	}
	return num
}

function getDivisions(times, timeIncrement) {
	let divisions = []
	for (let i = 0; i < 3; i++) {
		divisions.push(Math.ceil(times[i] / timeIncrement))
	}
	return divisions
}

function getTotalThreads(ns, servers, ramPerThread) {
	let num = 0
	for (const server of servers) {
		num += getServerThreads(ns, server, ramPerThread)
	}
	return num
}